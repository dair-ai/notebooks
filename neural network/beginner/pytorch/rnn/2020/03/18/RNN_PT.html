<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Building RNNs is Fun with PyTorch and Google Colab | Notebooks by dair.ai</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Building RNNs is Fun with PyTorch and Google Colab" />
<meta name="author" content="Elvis Saravia" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This notebook teaches you how to build a recurrent neural network (RNN) with a single layer, consisting of one single neuron. It also teaches how to implement a simple RNN-based model for image classification." />
<meta property="og:description" content="This notebook teaches you how to build a recurrent neural network (RNN) with a single layer, consisting of one single neuron. It also teaches how to implement a simple RNN-based model for image classification." />
<link rel="canonical" href="https://dair-ai.github.io/notebooks/neural%20network/beginner/pytorch/rnn/2020/03/18/RNN_PT.html" />
<meta property="og:url" content="https://dair-ai.github.io/notebooks/neural%20network/beginner/pytorch/rnn/2020/03/18/RNN_PT.html" />
<meta property="og:site_name" content="Notebooks by dair.ai" />
<meta property="og:image" content="https://dair-ai.github.io/notebooks/images/rnn-pt.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-18T00:00:00-05:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Elvis Saravia"},"description":"This notebook teaches you how to build a recurrent neural network (RNN) with a single layer, consisting of one single neuron. It also teaches how to implement a simple RNN-based model for image classification.","headline":"Building RNNs is Fun with PyTorch and Google Colab","dateModified":"2020-03-18T00:00:00-05:00","datePublished":"2020-03-18T00:00:00-05:00","@type":"BlogPosting","image":"https://dair-ai.github.io/notebooks/images/rnn-pt.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://dair-ai.github.io/notebooks/neural%20network/beginner/pytorch/rnn/2020/03/18/RNN_PT.html"},"url":"https://dair-ai.github.io/notebooks/neural%20network/beginner/pytorch/rnn/2020/03/18/RNN_PT.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/notebooks/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://dair-ai.github.io/notebooks/feed.xml" title="Notebooks by dair.ai" /><link rel="shortcut icon" type="image/x-icon" href="/notebooks/images/favicon.png">
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Building RNNs is Fun with PyTorch and Google Colab | Notebooks by dair.ai</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Building RNNs is Fun with PyTorch and Google Colab" />
<meta name="author" content="Elvis Saravia" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This notebook teaches you how to build a recurrent neural network (RNN) with a single layer, consisting of one single neuron. It also teaches how to implement a simple RNN-based model for image classification." />
<meta property="og:description" content="This notebook teaches you how to build a recurrent neural network (RNN) with a single layer, consisting of one single neuron. It also teaches how to implement a simple RNN-based model for image classification." />
<link rel="canonical" href="https://dair-ai.github.io/notebooks/neural%20network/beginner/pytorch/rnn/2020/03/18/RNN_PT.html" />
<meta property="og:url" content="https://dair-ai.github.io/notebooks/neural%20network/beginner/pytorch/rnn/2020/03/18/RNN_PT.html" />
<meta property="og:site_name" content="Notebooks by dair.ai" />
<meta property="og:image" content="https://dair-ai.github.io/notebooks/images/rnn-pt.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-18T00:00:00-05:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Elvis Saravia"},"description":"This notebook teaches you how to build a recurrent neural network (RNN) with a single layer, consisting of one single neuron. It also teaches how to implement a simple RNN-based model for image classification.","headline":"Building RNNs is Fun with PyTorch and Google Colab","dateModified":"2020-03-18T00:00:00-05:00","datePublished":"2020-03-18T00:00:00-05:00","@type":"BlogPosting","image":"https://dair-ai.github.io/notebooks/images/rnn-pt.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://dair-ai.github.io/notebooks/neural%20network/beginner/pytorch/rnn/2020/03/18/RNN_PT.html"},"url":"https://dair-ai.github.io/notebooks/neural%20network/beginner/pytorch/rnn/2020/03/18/RNN_PT.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="https://dair-ai.github.io/notebooks/feed.xml" title="Notebooks by dair.ai" />

<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/notebooks/">Notebooks by dair.ai</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/notebooks/about/">About Me</a><a class="page-link" href="/notebooks/search/">Search</a><a class="page-link" href="/notebooks/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Building RNNs is Fun with PyTorch and Google Colab</h1><p class="page-description">This notebook teaches you how to build a recurrent neural network (RNN) with a single layer, consisting of one single neuron. It also teaches how to implement a simple RNN-based model for image classification.</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2020-03-18T00:00:00-05:00" itemprop="datePublished">
        Mar 18, 2020
      </time>• 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Elvis Saravia</span></span>
       • <span class="read-time" title="Estimated read time">
    
    
      15 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/notebooks/categories/#neural network">neural network</a>
        &nbsp;
      
        <a class="category-tags-link" href="/notebooks/categories/#beginner">beginner</a>
        &nbsp;
      
        <a class="category-tags-link" href="/notebooks/categories/#pytorch">pytorch</a>
        &nbsp;
      
        <a class="category-tags-link" href="/notebooks/categories/#rnn">rnn</a>
        
      
      </p>
    

    
      
        <div class="pb-5 d-flex flex-wrap flex-justify-end">
          <div class="px-2">

    <a href="https://github.com/dair-ai/notebooks/tree/master/_notebooks/2020-03-18-RNN_PT.ipynb" role="button" target="_blank">
<img class="notebook-badge-image" src="/notebooks/assets/badges/github.svg" alt="View On GitHub">
    </a>
</div>

          <div class="px-2">
    <a href="https://mybinder.org/v2/gh/dair-ai/notebooks/master?filepath=_notebooks%2F2020-03-18-RNN_PT.ipynb" target="_blank">
        <img class="notebook-badge-image" src="/notebooks/assets/badges/binder.svg" alt="Open In Binder"/>
    </a>
</div>

          <div class="px-2">
    <a href="https://colab.research.google.com/github/dair-ai/notebooks/blob/master/_notebooks/2020-03-18-RNN_PT.ipynb" target="_blank">
        <img class="notebook-badge-image" src="/notebooks/assets/badges/colab.svg" alt="Open In Colab"/>
    </a>
</div>
        </div>
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2020-03-18-RNN_PT.ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="About">About<a class="anchor-link" href="#About"> </a></h2><p>In this tutorial, I will first teach you how to build a recurrent neural network (RNN) with a single layer, consisting of one single neuron, with PyTorch and Google Colab. I will also show you how to implement a simple RNN-based model for image classification.</p>
<p>This work is heavily inspired by Aurélien Géron's book called <a href="https://www.oreilly.com/library/view/hands-on-machine-learning/9781491962282/">"Hand-On Machine Learning with Scikit-Learn and TensorFlow"</a>. Although his neural network implementations are purely in TensorFlow, I adopted/reused some notations/variables names and implemented things using PyTorch only. I really enjoyed his book and learned a lot from his explanations. His work inspired this tutorial and I strongly recommend the book.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We first import the necessary libraries we will use in the tutorial:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="RNN-with-A-Single-Neuron">RNN with A Single Neuron<a class="anchor-link" href="#RNN-with-A-Single-Neuron"> </a></h3><p>The idea of this tutorial is to show you the basic operations necessary for building an RNN architecture using PyTorch. This guide assumes you have knowledge of basic RNNs and that you have read the tutorial on <a href="https://medium.com/dair-ai/a-simple-neural-network-from-scratch-with-pytorch-and-google-colab-c7f3830618e0">building neural networks from scratch using PyTorch</a>. I will try to review RNNs wherever possible for those that need a refresher but I will keep it minimal.</p>
<p>First, let's build the computation graph for a single-layer RNN. Again, we are not concerned with the math for now, I just want to show you the PyTorch operations needed to build your RNN models.</p>
<p>For illustration purposes, this is the architecture we are building:</p>
<p><img src="https://docs.google.com/drawings/d/e/2PACX-1vQXBLYvvI1dqAHdLA0hQdsP1PojmCfuSCMK2DXEL0uTvRUqvD1eYK8fsECcNCoekxCbgWJ-k7QF_1s4/pub?w=600&amp;h=400" alt="alt txt" /></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And here is the code:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">SingleRNN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SingleRNN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">Wx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">)</span> <span class="c1"># 4 X 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Wy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">)</span> <span class="c1"># 1 X 1</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">)</span> <span class="c1"># 1 X 4</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">X1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Y0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="n">X0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wx</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="c1"># 4 X 1</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">Y1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wy</span><span class="p">)</span> <span class="o">+</span>
                            <span class="n">torch</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wx</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="c1"># 4 X 1</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y1</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In the above code, I have implemented a simple one layer, one neuron RNN. I initialized two weight matrices, <code>Wx</code> and <code>Wy</code> with values from a normal distribution. <code>Wx</code> contains connection weights for the inputs of the current time step, while <code>Wy</code> contains connection weights for the outputs of the previous time step. We added a bias <code>b</code>. The <code>forward</code> function computes two outputs -- one for each time step... two in this case. Note that we are using <code>tanh</code> as the nonlinearity (activation function).</p>
<p>As for the input, we are providing 4 instances, with each instance containing two input sequences.</p>
<p>For illustration purposes, this is how the data is being fed into the RNN model:</p>
<p><img src="https://docs.google.com/drawings/d/e/2PACX-1vRpQYtOzO1U_3yQLf1885kMaja6MsXtJ8QnlqxrfpTgZmb4WpewJXphGdmotYXDB1VE6zlW6cBY_WqR/pub?w=600&amp;h=600" alt="alt txt" /></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And this is the code to test the model:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">N_INPUT</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">N_NEURONS</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">X0_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="c1">#t=0 =&gt; 4 X 4</span>

<span class="n">X1_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="c1">#t=1 =&gt; 4 X 4</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">SingleRNN</span><span class="p">(</span><span class="n">N_INPUT</span><span class="p">,</span> <span class="n">N_NEURONS</span><span class="p">)</span>

<span class="n">Y0_val</span><span class="p">,</span> <span class="n">Y1_val</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">X0_batch</span><span class="p">,</span> <span class="n">X1_batch</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>After we have fed the input into the computation graph, we obtain outputs for each timestep (<code>Y0</code>, <code>Y1</code>), which we can now print as follows:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">Y0_val</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Y1_val</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>tensor([[-0.1643],
        [-0.9995],
        [-1.0000],
        [-1.0000]])
tensor([[-1.0000],
        [-0.6354],
        [-1.0000],
        [-0.9998]])
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Increasing-Neurons-in-RNN-Layer">Increasing Neurons in RNN Layer<a class="anchor-link" href="#Increasing-Neurons-in-RNN-Layer"> </a></h3><p>Next, I will show you how to generalize the RNN we have just build to let the single layer support an <code>n</code> amount of neurons. In terms of the architecture, nothing really changes since we have already parameterized the number of neurons in the computation graph we have built. However, the size of the output changes since we have changed the size of number of units (i.e., neurons) in the RNN layer. </p>
<p>Here is an illustration of what we will build:</p>
<p><img src="https://docs.google.com/drawings/d/e/2PACX-1vQov6BGg1fXOb7Bg5zenPh7R5j6VsZJh_D6JevQ_sm_fCxmXORxad3qLIFGG1FojzJig0qdcAQoGYoN/pub?w=600&amp;h=404" alt="alt txt" /></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And here is the code:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">BasicRNN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BasicRNN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">Wx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">)</span> <span class="c1"># n_inputs X n_neurons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Wy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">)</span> <span class="c1"># n_neurons X n_neurons</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">)</span> <span class="c1"># 1 X n_neurons</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="n">X1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Y0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="n">X0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wx</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="c1"># batch_size X n_neurons</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">Y1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Y0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wy</span><span class="p">)</span> <span class="o">+</span>
                            <span class="n">torch</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wx</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="c1"># batch_size X n_neurons</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y1</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">N_INPUT</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># number of features in input</span>
<span class="n">N_NEURONS</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># number of units in layer</span>

<span class="n">X0_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> 
                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="c1">#t=0 =&gt; 4 X 3</span>

<span class="n">X1_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="c1">#t=1 =&gt; 4 X 3</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">BasicRNN</span><span class="p">(</span><span class="n">N_INPUT</span><span class="p">,</span> <span class="n">N_NEURONS</span><span class="p">)</span>

<span class="n">Y0_val</span><span class="p">,</span> <span class="n">Y1_val</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">X0_batch</span><span class="p">,</span> <span class="n">X1_batch</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now when we print the outputs produced for each time step, it is of size (<code>4 X 5</code>), which represents the batch size and number of neurons, respectively.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">Y0_val</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Y1_val</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>tensor([[ 0.9975, -0.9785,  0.9822, -0.8972,  0.9929],
        [ 0.9999, -0.9998,  1.0000, -0.9865,  0.9447],
        [ 1.0000, -1.0000,  1.0000, -0.9983,  0.6298],
        [-1.0000,  0.9915,  0.7409,  1.0000, -1.0000]])
tensor([[ 0.9858, -1.0000,  1.0000, -0.8826, -1.0000],
        [ 0.1480, -0.8635, -0.4498,  0.3516, -0.2848],
        [-0.1455, -0.9988,  1.0000,  0.0260, -0.9997],
        [-0.4084,  0.9973,  0.8858,  0.0783, -0.9993]])
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="PyTorch-Built-in-RNN-Cell">PyTorch Built-in RNN Cell<a class="anchor-link" href="#PyTorch-Built-in-RNN-Cell"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If you take a closer look at the <code>BasicRNN</code> computation graph we have just built, it has a serious flaw. What if we wanted to build an architecture that supports extremely large inputs and outputs. The way it is currently built, it would require us to individually compute the outputs for every time step, increasing the lines of code needed to implement the desired computation graph. Below I will show you how to consolidate and implement this more efficiently and cleanly using the built-in RNNCell module.</p>
<p>Let's first try to implement this informally to analyze the role <code>RNNCell</code> plays:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">rnn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">RNNCell</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1"># n_input X n_neurons</span>

<span class="n">X_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> 
                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="p">[[</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
                       <span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="c1"># X0 and X1</span>

<span class="n">hx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1"># m X n_neurons</span>
<span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># for each time step</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">hx</span> <span class="o">=</span> <span class="n">rnn</span><span class="p">(</span><span class="n">X_batch</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hx</span><span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hx</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[tensor([[ 0.2545,  0.7355,  0.3708, -0.6381,  0.0402],
        [-0.3379,  0.9996,  0.9976, -0.9769,  0.6668],
        [-0.9940,  1.0000,  1.0000, -0.9992,  0.4488],
        [-0.7486,  0.9925,  0.9862, -0.9642,  0.9990]], grad_fn=&lt;TanhBackward&gt;), tensor([[-0.9848,  1.0000,  1.0000, -0.9999,  0.9970],
        [ 0.2496, -0.7512,  0.1730, -0.3533, -0.7347],
        [-0.9502,  0.9998,  0.9995, -0.9966,  0.9119],
        [-0.6488,  0.7944,  0.9580, -0.9171,  0.2384]], grad_fn=&lt;TanhBackward&gt;)]
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With the above code, we have basically implemented the same model that was implemented in <code>BasicRNN</code>. <code>torch.RNNCell(...)</code> does all the magic of creating and maintaining the necessary weights and biases for us. <code>torch.RNNCell</code> accepts a tensor as input and outputs the next hidden state for each element in the batch. Read more about this module <a href="https://pytorch.org/docs/stable/nn.html?highlight=rnncell#torch.nn.RNNCell">here</a>.</p>
<p>Now, let's formally build the computation graph using the same information we used above.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">CleanBasicRNN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CleanBasicRNN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">RNNCell</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">)</span> <span class="c1"># initialize hidden state</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># for each time step</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">hx</span><span class="p">)</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hx</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hx</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">FIXED_BATCH_SIZE</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># our batch size is fixed for now</span>
<span class="n">N_INPUT</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">N_NEURONS</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">X_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> 
                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="p">[[</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
                       <span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="c1"># X0 and X1</span>


<span class="n">model</span> <span class="o">=</span> <span class="n">CleanBasicRNN</span><span class="p">(</span><span class="n">FIXED_BATCH_SIZE</span><span class="p">,</span> <span class="n">N_INPUT</span><span class="p">,</span> <span class="n">N_NEURONS</span><span class="p">)</span>
<span class="n">output_val</span><span class="p">,</span> <span class="n">states_val</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">X_batch</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output_val</span><span class="p">)</span> <span class="c1"># contains all output for all timesteps</span>
<span class="nb">print</span><span class="p">(</span><span class="n">states_val</span><span class="p">)</span> <span class="c1"># contain values for final state or final timestep, i.e., t=1</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[tensor([[ 0.4582, -0.9106,  0.0743, -0.9608,  0.9272],
        [ 0.2087, -0.9999, -0.9486, -0.9969,  0.9996],
        [-0.2371, -1.0000, -0.7662, -1.0000,  1.0000],
        [-0.9576, -0.9306, -0.1201, -0.9781,  0.9277]], grad_fn=&lt;TanhBackward&gt;), tensor([[-0.9237, -1.0000, -0.9743, -1.0000,  1.0000],
        [-0.3181, -0.6270, -0.6122,  0.1921,  0.0647],
        [-0.7835, -0.9991, -0.9098, -0.9999,  0.9976],
        [-0.5765, -0.8469, -0.5469, -0.9785,  0.7512]], grad_fn=&lt;TanhBackward&gt;)]
tensor([[-0.9237, -1.0000, -0.9743, -1.0000,  1.0000],
        [-0.3181, -0.6270, -0.6122,  0.1921,  0.0647],
        [-0.7835, -0.9991, -0.9098, -0.9999,  0.9976],
        [-0.5765, -0.8469, -0.5469, -0.9785,  0.7512]], grad_fn=&lt;TanhBackward&gt;)
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You can see how the code is much cleaner since we don't need to explicitly operate on the weights as shown in the previous code snippet  --  everything is handled implicitly and eloquently behind the scenes by PyTorch.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="RNN-for-Image-Classification">RNN for Image Classification<a class="anchor-link" href="#RNN-for-Image-Classification"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="https://docs.google.com/drawings/d/e/2PACX-1vSiMstqkE9hTYmhPD3KMeFRNNKYA2NnrCayahBOEL1TalRqaWF7rH8a7O-nP9c-mKOdZRsWtmAGZfNN/pub?w=969&amp;h=368" alt="alt txt" /></p>
<p>Now that you have learned how to build a simple RNN from scratch and using the built-in <code>RNNCell</code> module provided in PyTorch, let's do something more sophisticated and special.</p>
<p>Let's try to build an image classifier using the MNIST dataset. The MNIST dataset consists of images that contain hand-written numbers from 1–10. Essentially, we want to build a classifier to predict the numbers displayed by a set of images. I know this sounds strange but you will be surprised by how well RNNs perform on this image classification task.</p>
<p>In addition, we will also be using the <code>RNN</code> module instead of the <code>RNNCell</code> module since we want to generalize the computation graph to be able to support an <code>n</code> number of layers as well. We will only use one layer in the following computation graph, but you can experiment with the code later on by adding more layers.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Importing-the-dataset">Importing the dataset<a class="anchor-link" href="#Importing-the-dataset"> </a></h4><p>Before building the RNN-based computation graph, let's import the MNIST dataset, split it into test and train portions, do a few transformations, and further explore it. You will need the following PyTorch libraries and lines of code to download and import the MNIST dataset to Google Colab.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">torchvision</span>
<span class="kn">import</span> <span class="nn">torchvision.transforms</span> <span class="k">as</span> <span class="nn">transforms</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%%capture</span>
<span class="n">BATCH_SIZE</span> <span class="o">=</span> <span class="mi">64</span>

<span class="c1"># list all transformations</span>
<span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">(</span>
    <span class="p">[</span><span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">()])</span>

<span class="c1"># download and load training dataset</span>
<span class="n">trainset</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">MNIST</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="s1">&#39;./data&#39;</span><span class="p">,</span> <span class="n">train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>
<span class="n">trainloader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">trainset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">BATCH_SIZE</span><span class="p">,</span>
                                          <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># download and load testing dataset</span>
<span class="n">testset</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">MNIST</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="s1">&#39;./data&#39;</span><span class="p">,</span> <span class="n">train</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>
<span class="n">testloader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">testset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">BATCH_SIZE</span><span class="p">,</span>
                                         <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The code above loads and prepares the dataset to be fed into the computation graph we will build later on. Take a few minutes to play around with the code and understand what is happening. Notice that we needed to provide a batch size. This is because <code>trainloader</code> and <code>testloader</code> are iterators which will make it easier when we are iterating on the dataset and training our RNN model with minibatches.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Exloring-the-dataset">Exloring the dataset<a class="anchor-link" href="#Exloring-the-dataset"> </a></h4><p>Here is a few lines of code to explore the dataset. I won't cover much of what's going on here, but you can take some time and look at it by yourself.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># functions to show an image</span>
<span class="k">def</span> <span class="nf">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
    <span class="c1">#img = img / 2 + 0.5     # unnormalize</span>
    <span class="n">npimg</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">npimg</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>

<span class="c1"># get some random training images</span>
<span class="n">dataiter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">trainloader</span><span class="p">)</span>
<span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">dataiter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>

<span class="c1"># show images</span>
<span class="n">imshow</span><span class="p">(</span><span class="n">torchvision</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">make_grid</span><span class="p">(</span><span class="n">images</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
FE6ePLlatmrVqsWrV6+yoKCAPj4+NDc3f6auWFtbc+nSpczNzeXu3bs1/lCYmJiwQYMGHD16NDdv
3szExESqVCrK5XJmZ2e/ygv5SvL+++8/t0737duXu3fvZuPGjRkeHs5Tp069jGzefBKoU6cO7ezs
2KhRI3p6enLu3LkMDw+nQqFgYWEhN23apPFNBx73/7t27UoXF5dKj+/bt4+ZmZl0d3evdgXas2cP
c3NzuWjRIhoZGamPubi48PDhw1y9ejUtLCx4/fp1lpaWcuvWrRqV6ebNm+ovfmlpKQsKCtS/Y2Nj
ef36dX788cfs0aOHxvfPysqKfn5+av3R0dH8/vvv6eLiwr8GgQk87jdv2LCBCoWCwcHB7NmzZ5Vt
mZmZ8aeffqJMJuPevXtpaWlZ4bggCGzWrBnPnz/PtLQ0rl27VqPxHEEQ6OzszGXLljEkJIQqlUpN
dHl5eTx37hwnTZqklTEOAJw0aRIvX75MZ2fnZ461bNmSfn5+vHPnDuPj4ysdc3lK3lwSMDAw4Lhx
47hhwwbu3buXfn5+TEpKYlFRkXqQMCkpiQsXLmTDhg21cvOfJ4aGhrx16xZ/+eWXauvo0aMHHz58
yMuXL9PQ0LDCMUtLS44fP57t2rWjnp4er1+/ToVCwaCgoGrbc3R0ZEhIiJoEcnJyeOzYMUZGRvL8
+fMcNmxYBSLSVAYOHEipVEqpVMpr165x+PDhrFWrVoVzjIyMuH//fioUCqampvLjjz+u1sDj5MmT
mZmZyWvXrj0zIKynp8dOnTrR19eXSUlJ/PLLL2ljY6NR2Xr16sUjR45QLpdToVBQpVKxqKiI169f
57Jly+jo6KjV+tavXz9mZGRw27ZttLOzU5fL1dWVS5cuZX5+PrOysjh79uxqDwy+dgJ4FRLw8vJS
N1nLWVelUjE2Npa3b99WN3Pz8vJ46NAh9unThxKJRKsPo1yGDh3KgoICTpkypdo6xowZw+TkZP7+
++/PfLmelvKWwNGjR6ttb8SIEczIyFCTQG5uLo8fP87jx49z9uzZdHJy0tqXCwDbt2/P06dP8+jR
o+zcuTP19PQqHNfT0+OoUaOYlZXF7OxsLlu27Jn+7quIsbExfX19mZubS29v7wrHJBIJe/XqRT8/
P4aGhnLGjBnPEG5VxcrKirdv36ZCoeDNmzd5/PhxFhQU8Pfff2enTp0oFou1Xt/Mzc35ww8/MCMj
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
" />
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Model">Model<a class="anchor-link" href="#Model"> </a></h4><p>Let's construct the computation graph. Below are the parameters:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># parameters </span>
<span class="n">N_STEPS</span> <span class="o">=</span> <span class="mi">28</span>
<span class="n">N_INPUTS</span> <span class="o">=</span> <span class="mi">28</span>
<span class="n">N_NEURONS</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">N_OUTPUTS</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">N_EPHOCS</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And finally, here is a figure of the RNN-based classification model we are building:</p>
<p><img src="https://docs.google.com/drawings/d/e/2PACX-1vQWhELhewvq_bHgqwf4vwDb5B9DN9-jAxeTF9Y73zr-OsW6OXC-ngxAfojivXyZEhjzLXceTZU2Ncz3/pub?w=550&amp;h=600" alt="alt txt" /></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And here is the code for the model:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">ImageRNN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">,</span> <span class="n">n_inputs</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">,</span> <span class="n">n_outputs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ImageRNN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neurons</span> <span class="o">=</span> <span class="n">n_neurons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_steps</span> <span class="o">=</span> <span class="n">n_steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">=</span> <span class="n">n_inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span> <span class="o">=</span> <span class="n">n_outputs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">basic_rnn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">RNN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neurons</span><span class="p">)</span> 
        
        <span class="bp">self</span><span class="o">.</span><span class="n">FC</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neurons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">init_hidden</span><span class="p">(</span><span class="bp">self</span><span class="p">,):</span>
        <span class="c1"># (num_layers, batch_size, n_neurons)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neurons</span><span class="p">))</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="c1"># transforms X to dimensions: n_steps X batch_size X n_inputs</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> 
        
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_hidden</span><span class="p">()</span>
        
        <span class="c1"># lstm_out =&gt; n_steps, batch_size, n_neurons (hidden states for each time step)</span>
        <span class="c1"># self.hidden =&gt; 1, batch_size, n_neurons (final state from each lstm_out)</span>
        <span class="n">lstm_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_rnn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden</span><span class="p">)</span>      
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FC</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_outputs</span><span class="p">)</span> <span class="c1"># batch_size X n_output</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The <code>ImageRNN</code> model is doing the following:</p>
<ul>
<li>The initialization function <code>__init__(...)</code> declares a few variables, and then a basic RNN layer <code>basic_rnn</code> followed by a fully-connected layer <code>self.FC</code>.</li>
<li>The <code>init_hidden</code> function initializes hidden weights with zero values. 
The <code>forward</code> function accepts an input of size <code>n_steps X batch_size X n_neurons</code>. Then the data flows through the RNN layer and then through the fully-connected layer. </li>
<li>The output are the log probabilities of the model.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Testing-the-model-with-some-samples">Testing the model with some samples<a class="anchor-link" href="#Testing-the-model-with-some-samples"> </a></h4><p>A very good practice encouraged by PyTorch developers throughout their documentation, and which I really like and highly recommend, is to always test the model with a portion of the dataset before actual training. This is to ensure that you have the correct dimension specified and that the model is outputing the information you expect. Below I show an example of how to test your model:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dataiter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">trainloader</span><span class="p">)</span>
<span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">dataiter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">ImageRNN</span><span class="p">(</span><span class="n">BATCH_SIZE</span><span class="p">,</span> <span class="n">N_STEPS</span><span class="p">,</span> <span class="n">N_INPUTS</span><span class="p">,</span> <span class="n">N_NEURONS</span><span class="p">,</span> <span class="n">N_OUTPUTS</span><span class="p">)</span>
<span class="n">logits</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span><span class="mi">28</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">logits</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>tensor([[-0.0937, -0.0978, -0.0586,  0.0161,  0.0557,  0.0227, -0.0226, -0.0067,
          0.1092, -0.1295],
        [-0.0878, -0.0855, -0.0318,  0.0267,  0.0569,  0.0349, -0.0275,  0.0007,
          0.0999, -0.1215],
        [-0.0829, -0.1012, -0.0541,  0.0155,  0.0562,  0.0162, -0.0258, -0.0100,
          0.1077, -0.1310],
        [-0.1004, -0.0744, -0.0163,  0.0465,  0.0382,  0.0289, -0.0569,  0.0015,
          0.1003, -0.1266],
        [-0.0946, -0.0994, -0.0636,  0.0132,  0.0539,  0.0236, -0.0221, -0.0034,
          0.1013, -0.1298],
        [-0.0922, -0.0974, -0.0334,  0.0369,  0.0622,  0.0378, -0.0497,  0.0005,
          0.0983, -0.1160],
        [-0.0834, -0.0942, -0.0414,  0.0258,  0.0573,  0.0174, -0.0218, -0.0105,
          0.1045, -0.1307],
        [-0.0782, -0.0985, -0.0458,  0.0154,  0.0579,  0.0214, -0.0227, -0.0060,
          0.1035, -0.1269],
        [-0.1019, -0.0963, -0.0549,  0.0214,  0.0551,  0.0203, -0.0167, -0.0048,
          0.1131, -0.1316],
        [-0.1078, -0.1001, -0.0372,  0.0187,  0.0682,  0.0412, -0.0265, -0.0021,
          0.1033, -0.1191]], grad_fn=&lt;SliceBackward&gt;)
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Training">Training<a class="anchor-link" href="#Training"> </a></h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now let's look at the code for training the image classification model. But first, let's declare a few helper functions needed to train the model:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">torch.optim</span> <span class="k">as</span> <span class="nn">optim</span>

<span class="c1"># Device</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda:0&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

<span class="c1"># Model instance</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">ImageRNN</span><span class="p">(</span><span class="n">BATCH_SIZE</span><span class="p">,</span> <span class="n">N_STEPS</span><span class="p">,</span> <span class="n">N_INPUTS</span><span class="p">,</span> <span class="n">N_NEURONS</span><span class="p">,</span> <span class="n">N_OUTPUTS</span><span class="p">)</span>
<span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">CrossEntropyLoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_accuracy</span><span class="p">(</span><span class="n">logit</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Obtain accuracy for training round &#39;&#39;&#39;</span>
    <span class="n">corrects</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logit</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">size</span><span class="p">())</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">accuracy</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">corrects</span><span class="o">/</span><span class="n">batch_size</span>
    <span class="k">return</span> <span class="n">accuracy</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Before training a model in PyTorch, you can programatically specify what device you want to use during training; the <code>torch.device(...)</code> function tells the program that we want to use the GPU if one is available, otherwise the CPU will be the default device.</p>
<p>Then we create an instance of the model, <code>ImageRNN(...)``, with the proper parameters. The criterion represents the function we will use to compute the loss of the model. The</code>nn.CrossEntropyLoss()` function basically applies a log softmax followed by a negative log likelihood loss operation over the output of the model. To compute the loss, the function needs both the log probabilities and targets. We will see later in our code how to provide this to the criterion.</p>
<p>For training, we also need an optimization algorithm which helps to update weights based on the current loss. This is achieved with the <code>optim.Adam</code> optimization function, which requires the model parameters and a learning rate. Alternatively, you can also use <code>optim.SGD</code> or any other optimization algorithm that's available.</p>
<p>The <code>get_accuracy(...)</code> function simply computes the accuracy of the model given the log probabilities and target values. As an exercise, you can write code to test this function as we did with the model before.</p>
<p>Let's put everything together and train our image classification model:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_EPHOCS</span><span class="p">):</span>  <span class="c1"># loop over the dataset multiple times</span>
    <span class="n">train_running_loss</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">train_acc</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    
    <span class="c1"># TRAINING ROUND</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trainloader</span><span class="p">):</span>
         <span class="c1"># zero the parameter gradients</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        
        <span class="c1"># reset hidden states</span>
        <span class="n">model</span><span class="o">.</span><span class="n">hidden</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">init_hidden</span><span class="p">()</span> 
        
        <span class="c1"># get the inputs</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span><span class="mi">28</span><span class="p">)</span> 

        <span class="c1"># forward + backward + optimize</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

        <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

        <span class="n">train_running_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">train_acc</span> <span class="o">+=</span> <span class="n">get_accuracy</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">BATCH_SIZE</span><span class="p">)</span>
         
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Epoch:  </span><span class="si">%d</span><span class="s1"> | Loss: </span><span class="si">%.4f</span><span class="s1"> | Train Accuracy: </span><span class="si">%.2f</span><span class="s1">&#39;</span> 
          <span class="o">%</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">train_running_loss</span> <span class="o">/</span> <span class="n">i</span><span class="p">,</span> <span class="n">train_acc</span><span class="o">/</span><span class="n">i</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Epoch:  0 | Loss: 0.7489 | Train Accuracy: 75.88
Epoch:  1 | Loss: 0.3113 | Train Accuracy: 91.05
Epoch:  2 | Loss: 0.2325 | Train Accuracy: 93.33
Epoch:  3 | Loss: 0.1957 | Train Accuracy: 94.53
Epoch:  4 | Loss: 0.1706 | Train Accuracy: 95.21
Epoch:  5 | Loss: 0.1564 | Train Accuracy: 95.58
Epoch:  6 | Loss: 0.1471 | Train Accuracy: 95.91
Epoch:  7 | Loss: 0.1329 | Train Accuracy: 96.14
Epoch:  8 | Loss: 0.1283 | Train Accuracy: 96.42
Epoch:  9 | Loss: 0.1196 | Train Accuracy: 96.65
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can also compute accuracy on the testing dataset to test how well the model performs on the image classification task. As you can see below, our RNN model is performing very well on the MNIST classification task.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">test_acc</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">testloader</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>

    <span class="n">outputs</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

    <span class="n">test_acc</span> <span class="o">+=</span> <span class="n">get_accuracy</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">BATCH_SIZE</span><span class="p">)</span>
        
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Test Accuracy: </span><span class="si">%.2f</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span> <span class="n">test_acc</span><span class="o">/</span><span class="n">i</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Test Accuracy: 95.83
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Final-Words">Final Words<a class="anchor-link" href="#Final-Words"> </a></h3><p>Please notice that we are not using GPU in this tutorial since the models we are building are relatively simple. As an exercise, you can take a look at the <a href="https://pytorch.org/docs/stable/notes/cuda.html">PyTorch documentation</a> to learn how to program specific operations to execute on the GPU. You can then try to optimize the code to run on the GPU. If you need help with this, reach out to me on <a href="https://twitter.com/omarsar0">Twitter</a>.</p>
<p>That's it for this tutorial. Congratulations! You are now able to implement a basic RNN in PyTorch. You also learned how to apply RNNs to solve a real-world, image classification problem.</p>
<p>In the next tutorial, we will do more advanced things with RNNs and try to solve even more complex problems, such as sarcasm detection and sentiment classification. Until next time!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="References">References<a class="anchor-link" href="#References"> </a></h3><ul>
<li><a href="https://github.com/omarsar/pytorch_intro_neural_network/blob/master/nn.ipynb">A Simple Neural Network from Scratch with PyTorch and Google Colab</a></li>
<li><a href="http://shop.oreilly.com/product/0636920052289.do">Hands on Machine Learning with Scikit-learn and Tensorflow</a></li>
</ul>

</div>
</div>
</div>
</div>



  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="dair-ai/notebooks"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/notebooks/neural%20network/beginner/pytorch/rnn/2020/03/18/RNN_PT.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/notebooks/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/notebooks/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/notebooks/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Sharing data science notebooks made easy.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/dair-ai" title="dair-ai"><svg class="svg-icon grey"><use xlink:href="/notebooks/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/dair_ai" title="dair_ai"><svg class="svg-icon grey"><use xlink:href="/notebooks/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
